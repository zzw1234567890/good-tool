const vscode = require("vscode");
const fs = require("fs");
const {
  getAllScriptFiles,
  getModuleDir,
  getFileContent,
  getParentPath,
} = require("../util");
const { getDefinePath } = require("../global-config");
const { writeLog } = require("../log");

const { window, commands } = vscode;

const num = 25;

const autoGenerateDataByResult = async ({ fsPath: path }) => {
  try {
    const content = getFileContent(path);
    const defines = getDefines(content);
    const interfaceDefintions = getInterfaceDefinitions(path, defines);
    console.log(interfaceDefintions);
    if (Object.keys(interfaceDefintions).length === 0) {
      throw new Error("没有检测到可用的定义！");
    }
    const items = Object.keys(interfaceDefintions).map((v) => ({
      label: v,
      picked: true,
    }));
    const selectedKeys = await window.showQuickPick(items, {
      canPickMany: true,
    });
    if (!selectedKeys || selectedKeys.length === 0) {
      return;
    }
    let fileName = await window.showInputBox({
      title: "请输入生成数据定义文件名称",
    });
    if (!fileName) {
      return;
    }
    fileName.indexOf(".json") === -1 && (fileName += ".json");
    const selectedDefine = selectedKeys.map(
      (v) => interfaceDefintions[v.label]
    );
    generateDefineFile(fileName, selectedDefine);
  } catch (e) {
    writeLog(e.message);
    window.showInformationMessage("没有检测到可用的定义！");
  }
};

const getDefines = (content) => {
  const pattern = /useResult<(.*?)>\((.*?)\)/g;
  const defines = [];
  for (const match of content.matchAll(pattern)) {
    if (match.length === 3) {
      defines.push([match[1], match[2]]);
    }
  }
  return defines;
};

const getInterfaceDefinitions = (path, defines) => {
  const res = {};
  defines.map(([define]) => {
    const obj = { total: 0 };
    if (define.indexOf("[]") !== -1) {
      define = define.slice(0, -2);
      obj.total = num;
    }
    obj.columns = getDefinitionOne(path, define);
    res[define] = obj;
  });
  const scriptFiles = getAllScriptFiles(getModuleDir(path));
  for (const file of scriptFiles) {
    defines.map(([define, stateId]) => {
      const url = getUrl(file, stateId);
      if (url) {
        if (define.indexOf("[]") !== -1) {
          define = define.slice(0, -2);
        }
        res[define].url = url;
      }
    });
  }
  return res;
};

// 获取外部引用文件中的定义
const getDefinitionOne = (path, define) => {
  const content = getFileContent(path);
  const pattern = new RegExp(`import {.*?${define}.*?} from "(.*?)";`, "gs");
  const fileName = content
    .matchAll(pattern)
    .next()
    .value[1].replaceAll("/", "\\");
  path = getParentPath(path) + fileName;
  if (fs.existsSync(path + ".ts")) {
    path += ".ts";
  } else if (fs.existsSync(path + ".tsx")) {
    path += ".tsx";
  } else if (fs.existsSync(path + "\\index.ts")) {
    path += "\\index.ts";
  } else {
    path += "\\index.tsx";
  }
  return getInterfaceInfo(path, define);
};

// 获取path文件中的定义
const getInterfaceInfo = (path, define) => {
  const content = getFileContent(path);
  const pattern = new RegExp(`(interface|enum) ${define} \{(.*?)\}`, "gs");
  const match = content.matchAll(pattern).next();
  if (match.value) {
    // eslint-disable-next-line no-unused-vars
    const [_, type, value] = match.value;
    const str = value.replace(/\n|\r|\t| /g, "");
    return type === "interface" ? parseInterface(path, str) : parseEnum(str);
  }
};

// 获取url
const getUrl = (path, stateId) => {
  const content = getFileContent(path);
  let pattern = new RegExp(`stateId: ${stateId},`, "gs");
  const index = content.search(pattern);
  if (index == -1) {
    return;
  }
  let l = index,
    r = index;
  while (l > 0 && content.charAt(l--) !== "{");
  while (r < content.length && content.charAt(r++) !== "}");
  const match = content
    .slice(l + 1, r)
    .matchAll(/url: "(.*?)"/gs)
    .next();
  return "/rest/" + match.value[1];
};

// 解析interface
const parseInterface = (path, str) => {
  str = str.replace(/\n|\r|\t| /g, "");
  return str.split(/;|,/g).reduce((pre, value) => {
    console.log(value);
    if (value) {
      const t = value.split(":");
      pre[t[0]] = typeToString(t[0], t[1], path);
    }
    return pre;
  }, {});
};

// 解析enum
const parseEnum = (str) => {
  str = str.replace(/\n|\r|\t|"| /g, "");
  const res = str
    .split(",")
    .reduce((pre, value, index) => {
      if (!value) {
        return pre;
      }
      const t = value.split("=");
      if (t.length === 1) {
        pre.push(index === 0 ? 0 : Number(pre[index - 1]) + 1);
      } else {
        pre.push(t[1]);
      }
      return pre;
    }, [])
    .join(",");
  return `enum(${res})`;
};

const typeToString = (key, type, path) => {
  if (key.toLowerCase().includes("time") && type.includes("number")) {
    return type.includes("[]") ? `array(timestamp,${num})` : "timestamp";
  }
  const t = type.replace("[]", "");
  switch (t) {
    case "number":
    case "string":
    case "boolean":
      return type.includes("[]") ? `array(${t},${num})` : t;
    default:
      return type.includes("|")
        ? type
        : getDefineObj(path, type);
  }
};

const getDefineObj = (path, type) => {
  const obj = { total: 0 };
  const isArray = type.includes("[]");
  if(isArray){
    obj.total = num;
    type = type.replace("[]", "");
  }
  const columns = getInterfaceInfo(path, type) || getDefinitionOne(path, type);
  if (typeof columns === "string") {
    return isArray ? `array(${columns},${num})` : columns;
  } else {
    obj.columns = columns;
    return obj;
  }
};

const generateDefineFile = (fileName, selectedDefine) => {
  const path = (fileName = getDefinePath() + fileName);
  selectedDefine.forEach((define) => (define.method = "get"));
  fs.writeFileSync(path, JSON.stringify(selectedDefine));
  window.showInformationMessage("生成数据描述文件成功!");
  commands.executeCommand("good-tool.generateAnalogData", { fsPath: path });
};

module.exports = {
  autoGenerateDataByResult,
};
