const vscode = require("vscode");
const fs = require("fs");
const {
  getAllScriptFiles,
  getModuleDir,
  getFileContent,
  getParentPath,
} = require("../util");
const { getDefinePath } = require("../global-config");
const { writeLog } = require("../log");

const { window, commands } = vscode;

const num = 25;

const autoGenerateDataByResult = async ({ fsPath: path }) => {
  try {
    const content = getFileContent(path);
    const defines = getDefines(content);
    const interfaceDefintions = getInterfaceDefinitions(path, defines);
    console.log(interfaceDefintions);

    const keys = Object.keys(interfaceDefintions);
    const len = keys.length;
    let selectedDefine = [];
    if (len === 0) {
      throw new Error("没有检测到可用的类型！");
    } else if (len === 1) {
      // 如果当前文件中只有一个类型，跳过选择类型
      selectedDefine = [interfaceDefintions[keys[0]]];
    } else {
      const items = keys.map((v) => ({
        label: v,
        picked: true,
      }));
      const selectedKeys = await window.showQuickPick(items, {
        canPickMany: true,
      });
      if (!selectedKeys || selectedKeys.length === 0) {
        return;
      }
      selectedDefine = selectedKeys.map((v) => interfaceDefintions[v.label]);
    }

    let title = "请输入生成数据定义文件名称";
    let value;
    if (len === 1) {
      title = `检测到可用的类型：${keys[0]}，` + title;
      value = keys[0];
    } else {
      value = path.substring(path.lastIndexOf("\\") + 1, path.lastIndexOf("."));
    }
    let fileName = await window.showInputBox({ title, value });
    if (!fileName) {
      return;
    }
    fileName.indexOf(".json") === -1 && (fileName += ".json");
    generateDefineFile(fileName, selectedDefine);
  } catch (e) {
    writeLog(e.message);
    window.showInformationMessage("没有检测到可用的类型！");
  }
};

const getDefines = (content) => {
  const pattern = /useResult<(.*?)>\((.*?)\)/g;
  const defines = [];
  for (const match of content.matchAll(pattern)) {
    if (match.length === 3) {
      defines.push([match[1], match[2]]);
    }
  }
  return defines;
};

const getInterfaceDefinitions = (path, defines) => {
  const res = {};
  defines.map(([define]) => {
    const obj = { total: 0 };
    if (define.indexOf("[]") !== -1) {
      define = define.slice(0, -2);
      obj.total = num;
    }
    obj.columns =
      getInterfaceInfo(path, define) || getDefinitionOne(path, define);
    res[define] = obj;
  });
  const scriptFiles = getAllScriptFiles(getModuleDir(path));
  for (const file of scriptFiles) {
    defines.map(([define, stateId]) => {
      const url = getUrl(file, stateId);
      if (url) {
        if (define.indexOf("[]") !== -1) {
          define = define.slice(0, -2);
        }
        res[define].url = url;
      }
    });
  }
  for (const define in res) {
    if (!res[define].url) {
      window.showInformationMessage(
        `${define}对应的url没有找到，请检查stateId是否一致`
      );
    }
  }
  return res;
};

// 获取外部引用文件中的定义
const getDefinitionOne = (path, define) => {
  const content = getFileContent(path);
  const pattern = new RegExp(
    `import {.*?[ |,]${define}[ |,].*?} from "(.*?)";`,
    "gs"
  );
  const fileName = content
    .matchAll(pattern)
    .next()
    .value[1].replaceAll("/", "\\");
  path = getParentPath(path) + fileName;
  if (fs.existsSync(path + ".ts")) {
    path += ".ts";
  } else if (fs.existsSync(path + ".tsx")) {
    path += ".tsx";
  } else if (fs.existsSync(path + "\\index.ts")) {
    path += "\\index.ts";
  } else {
    path += "\\index.tsx";
  }
  return getInterfaceInfo(path, define);
};

// 获取path文件中的定义
const getInterfaceInfo = (path, define) => {
  const content = getFileContent(path);
  const pattern = new RegExp(
    `(interface|enum|type) ${define} (.*?)\{(.*?)\}`,
    "gs"
  );
  const match = content.matchAll(pattern).next();
  if (match.value) {
    // eslint-disable-next-line no-unused-vars
    const [_, type, parent, value] = match.value;
    let parentColumns = {};
    if (parent.includes("extends")) {
      const parents = parent.replace(/extends| /g, "").split(",");
      parentColumns = parseParents(path, parents);
    }
    let str = includeInnerClass(content, define, value);
    str = str
      .replace(/\/\/.*[/\n|\r|\t| ]/g, "")
      .replace(/"|'|\n|\r|\t| /g, "");
    if (type === "interface" || type === "type") {
      return { ...parentColumns, ...parseInterface(path, str) };
    }
    return parseEnum(str);
  }
};

// 支持继承
const parseParents = (path, parents) =>
  parents.reduce(
    (pre, define) => ({
      ...pre,
      ...(getInterfaceInfo(path, define) || getDefinitionOne(path, define)),
    }),
    {}
  );

// 兼容匿名内部类
const includeInnerClass = (content, define, value) => {
  let start = 0;
  while (true) {
    start = content.indexOf(value);
    if (content.slice(0, start).includes(` ${define} `)) {
      break;
    } else {
      content = content.slice(start + value.length);
    }
  }
  // 左括号数量
  let num = 0,
    end = start;
  while (end < content.length && num >= 0) {
    const c = content.charAt(end);
    if (c === "{") {
      num++;
    } else if (c === "}") {
      num--;
    }
    end++;
  }
  return content.slice(start, end - 1);
};

// 获取url
const getUrl = (path, stateId) => {
  const content = getFileContent(path);
  let pattern = new RegExp(`stateId: ${stateId},`, "gs");
  const index = content.search(pattern);
  if (index == -1) {
    return;
  }
  let l = index,
    r = index;
  while (l > 0 && content.charAt(l--) !== "{");
  while (r < content.length && content.charAt(r++) !== "}");
  const match = content
    .slice(l + 1, r)
    .matchAll(/url: "(.*?)"/gs)
    .next();
  return match.value ? "/rest/" + match.value[1] : "";
};

// 解析interface
const parseInterface = (path, str) => {
  const res = {};
  const arr = str.split(/[;,]/g);
  for (let i = 0; i < arr.length; i++) {
    let value = arr[i];
    if (value.includes(":")) {
      const t = value.split(":");
      if (value.includes("{")) {
        // 兼容匿名内部类
        let leftNum = 1;
        while (leftNum > 0 && ++i < arr.length) {
          value += ";" + arr[i];
          if (arr[i].includes("{")) {
            leftNum++;
          } else if (arr[i].includes("}")) {
            leftNum--;
          }
        }
        const isArray = value.endsWith("[]");
        const objStr = value.slice(t[0].length + 2, isArray ? -3 : -1);
        res[t[0]] = {
          total: isArray ? num : 0,
          columns: parseInterface(path, objStr),
        };
      } else {
        t[0] = t[0].replace("?", "");
        res[t[0]] = typeToString(t[0], t[1], path);
      }
    }
  }
  return res;
};

// 解析enum
const parseEnum = (str) => {
  const res = str
    .split(",")
    .reduce((pre, value, index) => {
      if (!value) {
        return pre;
      }
      const t = value.split("=");
      if (t.length === 1) {
        pre.push(index === 0 ? 0 : Number(pre[index - 1]) + 1);
      } else {
        pre.push(t[1]);
      }
      return pre;
    }, [])
    .join(",");
  return `enum(${res})`;
};

const typeToString = (key, type, path) => {
  if (key.toLowerCase().includes("time") && type.includes("number")) {
    return type.includes("[]") ? `array(timestamp,${num})` : "timestamp";
  }
  const t = type.replace("[]", "");
  switch (t) {
    case "number":
    case "string":
    case "boolean":
      return type.includes("[]") ? `array(${t},${num})` : t;
    default:
      return type.includes("|") ? type : getDefineObj(path, type);
  }
};

const getDefineObj = (path, type) => {
  const obj = { total: 0 };
  const isArray = type.includes("[]");
  if (isArray) {
    obj.total = num;
    type = type.replace("[]", "");
  }
  const columns = getInterfaceInfo(path, type) || getDefinitionOne(path, type);
  if (typeof columns === "string") {
    return isArray ? `array(${columns},${num})` : columns;
  } else {
    obj.columns = columns;
    return obj;
  }
};

const generateDefineFile = (fileName, selectedDefine) => {
  const path = (fileName = getDefinePath() + fileName);
  selectedDefine.forEach((define) => (define.method = "get"));
  fs.writeFileSync(path, JSON.stringify(selectedDefine));
  window.showInformationMessage("生成数据描述文件成功!");
  commands.executeCommand("good-tool.generateAnalogData", { fsPath: path });
};

module.exports = {
  autoGenerateDataByResult,
};
